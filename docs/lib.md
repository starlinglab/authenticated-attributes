# Library API docs

## Functions

<dl>
<dt><a href="#dbGet">dbGet(db, id, attr, sigKey, [encKey], [reduced])</a> ⇒ <code>object</code> | <code>null</code></dt>
<dd><p>Get verified output from the database.
Only properly signed entries will be returned.</p>
<p>If the value is encrypted and encKey is not provided, an error will be raised,
as this means the signature cannot be validated either.</p>
<p>The &quot;encrypted&quot; boolean will not be changed.</p>
<p>Timestamping is currently not validated.</p>
<p>null is returned if the key doesn&#39;t exist in the database.</p>
<p>Providing a batch instead of a db is allowed.</p>
</dd>
<dt><a href="#dbIsEncrypted">dbIsEncrypted(db, id, attr)</a> ⇒ <code>boolean</code> | <code>null</code></dt>
<dd><p>Returns if the attribute is listed as encrypted.</p>
<p>No signatures are validated.</p>
<p>null is returned if the key doesn&#39;t exist in the database.</p>
</dd>
<dt><a href="#dbRawValue">dbRawValue(db, id, attr)</a> ⇒ <code>*</code></dt>
<dd><p>Returns only the decoded value of the given attribute.
No signatures are validated!</p>
<p>Specifically the attestation value is returned.</p>
<p>null is returned if the key doesn&#39;t exist in the database.</p>
</dd>
<dt><a href="#setSigningKey">setSigningKey(privKey)</a></dt>
<dd><p>Set a global signing key for write operations.</p>
</dd>
<dt><a href="#dbPut">dbPut(db, id, attr, value, [encryptionKey])</a> ⇒ <code>*</code></dt>
<dd><p>Put data in the database.</p>
</dd>
<dt><a href="#dbAppend">dbAppend(db, id, attr, value, [encryptionKey])</a> ⇒ <code>*</code></dt>
<dd><p>Appends to an array in the database.</p>
<p>If the given attribute doesn&#39;t exist an array will be created.</p>
<p>If a non-array object is already stored under the given attribute an error
will be thrown.</p>
<p>The new value of the array is returned.</p>
<p>A batch is used so that the append is treated as one locked atomic operation,
not a separate read and write.</p>
</dd>
<dt><a href="#dbAddRelation">dbAddRelation(db, id, childOrParent, verb, relationCid)</a></dt>
<dd><p>Add a relation to the database according to our relationship schema.</p>
<p>If the given key and/or verb doesn&#39;t exist it will be created.</p>
<p>Duplicate CIDs in the array are allowed.</p>
<p>A batch is used so that the change is treated as one locked atomic operation,
not a separate read and write.</p>
</dd>
<dt><a href="#dbRemoveRelation">dbRemoveRelation(db, id, childOrParent, verb, relationCid)</a></dt>
<dd><p>Same as dbAddRelation. The first CID that matches the given one is removed.</p>
</dd>
<dt><a href="#dbUpgrade">dbUpgrade(db, id, attr, sigKey, [encryptionKey])</a> ⇒ <code>*</code></dt>
<dd><p>Upgrade the OTS timestamp of an attestation, then save that new timestamp.</p>
</dd>
<dt><a href="#keyFromPem">keyFromPem(pemPath)</a> ⇒ <code>Buffer</code></dt>
<dd><p>Extracts a 32-byte ed25519 private key from the given PEM/ASN encoded key file,
such as those generated by openssl.</p>
</dd>
</dl>

<a name="dbGet"></a>

## dbGet(db, id, attr, sigKey, [encKey], [reduced]) ⇒ <code>object</code> \| <code>null</code>
Get verified output from the database.
Only properly signed entries will be returned.

If the value is encrypted and encKey is not provided, an error will be raised,
as this means the signature cannot be validated either.

The "encrypted" boolean will not be changed.

Timestamping is currently not validated.

null is returned if the key doesn't exist in the database.

Providing a batch instead of a db is allowed.

**Kind**: global function  
**Returns**: <code>object</code> \| <code>null</code> - - see schema docs  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| db | <code>\*</code> |  | Hyperbee or batch |
| id | <code>string</code> |  | CID |
| attr | <code>string</code> |  | attribute/key |
| sigKey | <code>Uint8Array</code> |  | ed25519 public key |
| [encKey] | <code>Uint8Array</code> | <code>false</code> | 32 byte key, if decryption is needed |
| [reduced] | <code>boolean</code> | <code>false</code> | if set to true only the value and timestamp are returned, not the whole object |

<a name="dbIsEncrypted"></a>

## dbIsEncrypted(db, id, attr) ⇒ <code>boolean</code> \| <code>null</code>
Returns if the attribute is listed as encrypted.

No signatures are validated.

null is returned if the key doesn't exist in the database.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| db | <code>\*</code> | Hyperbee or batch |
| id | <code>string</code> | CID |
| attr | <code>string</code> | attribute/key |

<a name="dbRawValue"></a>

## dbRawValue(db, id, attr) ⇒ <code>\*</code>
Returns only the decoded value of the given attribute.
No signatures are validated!

Specifically the attestation value is returned.

null is returned if the key doesn't exist in the database.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| db | <code>\*</code> | Hyperbee or batch |
| id | <code>string</code> | CID |
| attr | <code>string</code> | attribute/key |

<a name="setSigningKey"></a>

## setSigningKey(privKey)
Set a global signing key for write operations.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| privKey | <code>Uint8Array</code> | ed25519 private key |

<a name="dbPut"></a>

## dbPut(db, id, attr, value, [encryptionKey]) ⇒ <code>\*</code>
Put data in the database.

**Kind**: global function  
**Returns**: <code>\*</code> - - underlying hyperbee db.put result, usually undefined  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| db | <code>\*</code> |  | Hyperbee or batch |
| id | <code>string</code> |  | CID |
| attr | <code>string</code> |  | attribute/key |
| value | <code>\*</code> |  | data to be stored, as JavaScript object |
| [encryptionKey] | <code>Uint8Array</code> | <code>false</code> | 32 byte key, if encryption is needed |

<a name="dbAppend"></a>

## dbAppend(db, id, attr, value, [encryptionKey]) ⇒ <code>\*</code>
Appends to an array in the database.

If the given attribute doesn't exist an array will be created.

If a non-array object is already stored under the given attribute an error
will be thrown.

The new value of the array is returned.

A batch is used so that the append is treated as one locked atomic operation,
not a separate read and write.

**Kind**: global function  
**Returns**: <code>\*</code> - - array as now stored in database  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| db | <code>\*</code> |  | Hyperbee |
| id | <code>string</code> |  | CID |
| attr | <code>string</code> |  | attribute/key |
| value | <code>\*</code> |  | data to be stored, as JavaScript object |
| [encryptionKey] | <code>Uint8Array</code> | <code>false</code> | 32 byte key, if encryption is needed |

<a name="dbAddRelation"></a>

## dbAddRelation(db, id, childOrParent, verb, relationCid)
Add a relation to the database according to our relationship schema.

If the given key and/or verb doesn't exist it will be created.

Duplicate CIDs in the array are allowed.

A batch is used so that the change is treated as one locked atomic operation,
not a separate read and write.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| db | <code>\*</code> | Hyperbee |
| id | <code>string</code> | CID |
| childOrParent | <code>string</code> | is either "children" or "parents" as the db key |
| verb | <code>string</code> | is a verb for the relation like "derived" or "transcoded" |
| relationCid | <code>CID</code> | is the CID object to be added as a relation |

<a name="dbRemoveRelation"></a>

## dbRemoveRelation(db, id, childOrParent, verb, relationCid)
Same as dbAddRelation. The first CID that matches the given one is removed.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| db | <code>\*</code> | Hyperbee |
| id | <code>string</code> | CID |
| childOrParent | <code>string</code> | is either "children" or "parents" as the db key |
| verb | <code>string</code> | is a verb for the relation like "derived" or "transcoded" |
| relationCid | <code>CID</code> | is the CID object to be added as a relation |

<a name="dbUpgrade"></a>

## dbUpgrade(db, id, attr, sigKey, [encryptionKey]) ⇒ <code>\*</code>
Upgrade the OTS timestamp of an attestation, then save that new timestamp.

**Kind**: global function  
**Returns**: <code>\*</code> - - underlying hyperbee db.put result, usually undefined  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| db | <code>\*</code> |  | Hyperbee or batch |
| id | <code>string</code> |  | CID |
| attr | <code>string</code> |  | attribute/key |
| sigKey | <code>Uint8Array</code> |  | ed25519 public key |
| [encryptionKey] | <code>Uint8Array</code> | <code>false</code> | 32 byte key, if encryption is needed |

<a name="keyFromPem"></a>

## keyFromPem(pemPath) ⇒ <code>Buffer</code>
Extracts a 32-byte ed25519 private key from the given PEM/ASN encoded key file,
such as those generated by openssl.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| pemPath | <code>string</code> | path to .pem file |

