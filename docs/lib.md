# Library API docs

## Functions

<dl>
<dt><a href="#dbGet">dbGet(db, id, attr, sigKey, [encKey], [reduced], [leaveEncrypted])</a> ⇒ <code>Promise.&lt;(object|null)&gt;</code></dt>
<dd><p>Get verified output from the database.
Only properly signed entries will be returned.</p>
<p>If the value is encrypted and encKey is not provided, a NeedsKeyError will be raised,
as this means the signature cannot be validated either.</p>
<p>The &quot;encrypted&quot; boolean will not be changed.</p>
<p>Timestamping is currently not validated.</p>
<p>null is returned if the key doesn&#39;t exist in the database.</p>
<p>Providing a batch instead of a db is allowed.</p>
</dd>
<dt><a href="#dbIsEncrypted">dbIsEncrypted(db, id, attr)</a> ⇒ <code>Promise.&lt;(boolean|null)&gt;</code></dt>
<dd><p>Returns if the attribute is listed as encrypted.</p>
<p>No signatures are validated.</p>
<p>null is returned if the key doesn&#39;t exist in the database.</p>
</dd>
<dt><a href="#dbRawValue">dbRawValue(db, id, attr)</a> ⇒ <code>Promise.&lt;*&gt;</code></dt>
<dd><p>Returns only the decoded value of the given attribute.
No signatures are validated!</p>
<p>Specifically the attestation value is returned.</p>
<p>null is returned if the key doesn&#39;t exist in the database.</p>
</dd>
<dt><a href="#setSigningKey">setSigningKey(privKey)</a></dt>
<dd><p>Set a global signing key for write operations.</p>
</dd>
<dt><a href="#dbPut">dbPut(db, id, attr, value, [encryptionKey])</a> ⇒ <code>Promise.&lt;*&gt;</code></dt>
<dd><p>Put data in the database.</p>
</dd>
<dt><a href="#dbAppend">dbAppend(db, id, attr, value, [encryptionKey])</a> ⇒ <code>Promise.&lt;*&gt;</code></dt>
<dd><p>Appends to an array in the database.</p>
<p>If the given attribute doesn&#39;t exist an array will be created.</p>
<p>If a non-array object is already stored under the given attribute an error
will be thrown.</p>
<p>The new value of the array is returned.</p>
<p>A batch is used so that the append is treated as one locked atomic operation,
not a separate read and write.</p>
</dd>
<dt><a href="#dbAddRelation">dbAddRelation(db, id, childOrParent, verb, relationCid)</a></dt>
<dd><p>Add a relation to the database according to our relationship schema.</p>
<p>If the given key and/or verb doesn&#39;t exist it will be created.</p>
<p>Duplicate CIDs in the array are allowed.</p>
<p>A batch is used so that the change is treated as one locked atomic operation,
not a separate read and write.</p>
</dd>
<dt><a href="#dbRemoveRelation">dbRemoveRelation(db, id, childOrParent, verb, relationCid)</a></dt>
<dd><p>Same as dbAddRelation. The first CID that matches the given one is removed.</p>
</dd>
<dt><a href="#dbUpgrade">dbUpgrade(db, id, attr, sigKey, [encryptionKey])</a> ⇒ <code>Promise.&lt;*&gt;</code></dt>
<dd><p>Upgrade the OTS timestamp of an attestation, then save that new timestamp.</p>
</dd>
<dt><a href="#decryptValue">decryptValue(msgWithNonce, encryptionKey)</a> ⇒ <code>*</code></dt>
<dd><p>Decrypt and decode an encrypted value from the database.</p>
</dd>
<dt><a href="#keyFromPem">keyFromPem(pemPath)</a> ⇒ <code>Promise.&lt;Buffer&gt;</code></dt>
<dd><p>Extracts a 32-byte ed25519 private key from the given PEM/ASN encoded key file,
such as those generated by openssl.</p>
</dd>
<dt><a href="#attToVC">attToVC(att)</a> ⇒ <code>string</code></dt>
<dd><p>Convert an attestation from the database into Verifiable Credentials format.</p>
</dd>
</dl>

<a name="dbGet"></a>

## dbGet(db, id, attr, sigKey, [encKey], [reduced], [leaveEncrypted]) ⇒ <code>Promise.&lt;(object\|null)&gt;</code>
Get verified output from the database.
Only properly signed entries will be returned.

If the value is encrypted and encKey is not provided, a NeedsKeyError will be raised,
as this means the signature cannot be validated either.

The "encrypted" boolean will not be changed.

Timestamping is currently not validated.

null is returned if the key doesn't exist in the database.

Providing a batch instead of a db is allowed.

**Kind**: global function  
**Returns**: <code>Promise.&lt;(object\|null)&gt;</code> - - see schema docs  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| db | <code>\*</code> |  | Hyperbee or batch |
| id | <code>string</code> |  | CID |
| attr | <code>string</code> |  | attribute/key |
| sigKey | <code>Uint8Array</code> |  | ed25519 public key |
| [encKey] | <code>Uint8Array</code> | <code>false</code> | 32 byte key, if decryption is needed |
| [reduced] | <code>boolean</code> | <code>false</code> | if set to true only the value and timestamp are returned, not the whole object |
| [leaveEncrypted] | <code>boolean</code> | <code>false</code> | set to true to leave value encrypted |

<a name="dbIsEncrypted"></a>

## dbIsEncrypted(db, id, attr) ⇒ <code>Promise.&lt;(boolean\|null)&gt;</code>
Returns if the attribute is listed as encrypted.

No signatures are validated.

null is returned if the key doesn't exist in the database.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| db | <code>\*</code> | Hyperbee or batch |
| id | <code>string</code> | CID |
| attr | <code>string</code> | attribute/key |

<a name="dbRawValue"></a>

## dbRawValue(db, id, attr) ⇒ <code>Promise.&lt;\*&gt;</code>
Returns only the decoded value of the given attribute.
No signatures are validated!

Specifically the attestation value is returned.

null is returned if the key doesn't exist in the database.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| db | <code>\*</code> | Hyperbee or batch |
| id | <code>string</code> | CID |
| attr | <code>string</code> | attribute/key |

<a name="setSigningKey"></a>

## setSigningKey(privKey)
Set a global signing key for write operations.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| privKey | <code>Uint8Array</code> | ed25519 private key |

<a name="dbPut"></a>

## dbPut(db, id, attr, value, [encryptionKey]) ⇒ <code>Promise.&lt;\*&gt;</code>
Put data in the database.

**Kind**: global function  
**Returns**: <code>Promise.&lt;\*&gt;</code> - - underlying hyperbee db.put result, usually undefined  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| db | <code>\*</code> |  | Hyperbee or batch |
| id | <code>string</code> |  | CID |
| attr | <code>string</code> |  | attribute/key |
| value | <code>\*</code> |  | data to be stored, as JavaScript object |
| [encryptionKey] | <code>Uint8Array</code> | <code>false</code> | 32 byte key, if encryption is needed |

<a name="dbAppend"></a>

## dbAppend(db, id, attr, value, [encryptionKey]) ⇒ <code>Promise.&lt;\*&gt;</code>
Appends to an array in the database.

If the given attribute doesn't exist an array will be created.

If a non-array object is already stored under the given attribute an error
will be thrown.

The new value of the array is returned.

A batch is used so that the append is treated as one locked atomic operation,
not a separate read and write.

**Kind**: global function  
**Returns**: <code>Promise.&lt;\*&gt;</code> - - array as now stored in database  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| db | <code>\*</code> |  | Hyperbee |
| id | <code>string</code> |  | CID |
| attr | <code>string</code> |  | attribute/key |
| value | <code>\*</code> |  | data to be stored, as JavaScript object |
| [encryptionKey] | <code>Uint8Array</code> | <code>false</code> | 32 byte key, if encryption is needed |

<a name="dbAddRelation"></a>

## dbAddRelation(db, id, childOrParent, verb, relationCid)
Add a relation to the database according to our relationship schema.

If the given key and/or verb doesn't exist it will be created.

Duplicate CIDs in the array are allowed.

A batch is used so that the change is treated as one locked atomic operation,
not a separate read and write.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| db | <code>\*</code> | Hyperbee |
| id | <code>string</code> | CID |
| childOrParent | <code>string</code> | is either "children" or "parents" as the db key |
| verb | <code>string</code> | is a verb for the relation like "derived" or "transcoded" |
| relationCid | <code>CID</code> | is the CID object to be added as a relation |

<a name="dbRemoveRelation"></a>

## dbRemoveRelation(db, id, childOrParent, verb, relationCid)
Same as dbAddRelation. The first CID that matches the given one is removed.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| db | <code>\*</code> | Hyperbee |
| id | <code>string</code> | CID |
| childOrParent | <code>string</code> | is either "children" or "parents" as the db key |
| verb | <code>string</code> | is a verb for the relation like "derived" or "transcoded" |
| relationCid | <code>CID</code> | is the CID object to be added as a relation |

<a name="dbUpgrade"></a>

## dbUpgrade(db, id, attr, sigKey, [encryptionKey]) ⇒ <code>Promise.&lt;\*&gt;</code>
Upgrade the OTS timestamp of an attestation, then save that new timestamp.

**Kind**: global function  
**Returns**: <code>Promise.&lt;\*&gt;</code> - - underlying hyperbee db.put result, usually undefined  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| db | <code>\*</code> |  | Hyperbee or batch |
| id | <code>string</code> |  | CID |
| attr | <code>string</code> |  | attribute/key |
| sigKey | <code>Uint8Array</code> |  | ed25519 public key |
| [encryptionKey] | <code>Uint8Array</code> | <code>false</code> | 32 byte key, if encryption is needed |

<a name="decryptValue"></a>

## decryptValue(msgWithNonce, encryptionKey) ⇒ <code>\*</code>
Decrypt and decode an encrypted value from the database.

**Kind**: global function  
**Returns**: <code>\*</code> - - the decrypted value as a JavaScript object (NOT dag-cbor bytes)  

| Param | Type | Description |
| --- | --- | --- |
| msgWithNonce | <code>\*</code> | the bytes of attestation.value as a Uint8Array or Buffer |
| encryptionKey | <code>\*</code> | a 32 byte decryption key (Uint8Array or Buffer) |

<a name="keyFromPem"></a>

## keyFromPem(pemPath) ⇒ <code>Promise.&lt;Buffer&gt;</code>
Extracts a 32-byte ed25519 private key from the given PEM/ASN encoded key file,
such as those generated by openssl.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| pemPath | <code>string</code> | path to .pem file |

<a name="attToVC"></a>

## attToVC(att) ⇒ <code>string</code>
Convert an attestation from the database into Verifiable Credentials format.

**Kind**: global function  
**Returns**: <code>string</code> - - VC as string of JSON  

| Param | Type | Description |
| --- | --- | --- |
| att | <code>object</code> | object returned by dbGet |

