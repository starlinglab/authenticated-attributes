# Authenticated Attributes

This repo contains the initial implementation of the Authenticated Attributes project from The Starling Lab. It is built on top of the [HyperBee](https://docs.holepunch.to/building-blocks/hyperbee) key-value store.

This repo also contains a specific frontend for Authenticated Attributes, designed to work within the asset management system [Uwazi](https://uwazi.io/).

## Repo Structure

```
authenticated-attributes
│
├── hyperbee               // Backend code
│   ├── demo-get.mjs       // Some demo scripts
│   ├── demo.mjs
│   ├── test-cbor.mjs
│   ├── import.mjs         // ZIP import script
│   ├── src                // Code for using db
│   │   └── ...
│   ├── server.mjs         // CRUD webserver for db
│   └── example.env        // Example server config
│
└── uwazi                  // Frontend code
    ├── add_cids.py        // Backend script to add CIDs to Uwazi uploads
    └── entity-page        // Custom UI for Uwazi files to see metadata
        ├── sw.js          // Service worker for WACZ embedding on Uwazi
        └── ...            // Svelte files
```

## Development

After cloning the repo, enter `hyperbee` and `uwazi/entity-page`, and run `npm install` in each to install dependencies. Enable pre-commit hooks with `git config core.hooksPath .githooks`. Now you should be ready to make code changes, and formatting and linting will happen automatically before committing.

## Keys

### Signing

Every attestation stored in the database is signed with an ed25519 keypair. The private key can be loaded from a PEM file such as those generated by `openssl`, or directly from a 32-byte `Buffer`.

An ed25519 private key can be generated with the command `openssl genpkey -algorithm ED25519`.

### Encryption

Attestations can optionally be encrypted on a per-attestation basis. Symmetric encryption is used, so a single secret key needs to be generated for encryption. This can just be a `Buffer` of 32 random bytes.

The NaCl API is used, so the specific encryption algorithm is xsalsa20-poly1305. The nonce is prepended before storing.

## Database

Hyperbee is a key-value database. For this codebase, the key is the CID of the asset, followed by a slash, followed by the name of the attestation. For example:

```
bafkreif7gtpfl7dwi5nflge2rsfp6vq6q5kkwfm7uvxyyezxhsnde5ly3y/description
```

The value is described below.

### Encoding

Database entries are stored as binary data, encoded with [DAG-CBOR](https://ipld.io/docs/codecs/known/dag-cbor/). This is like [CBOR](https://cbor.io/), but has canonical encoding and native support for CIDs. If you don't know CBOR, it's like JSON but binary. This allows for easy storage of binary data alongside any other types.

### Schema

```javascript
{
  signature: {
    pubKey: Uint8Array(32),
    signature: Uint8Array(64),
    // CID of "attestation" object
    signedMsg: CID(bafyreietqpflteqz6kj7lmdqz76kzkwdo65o4bhivxrmqvha7pdgixxos4)
  },
  timestamp: {
    proof: Uint8Array(503),
    upgraded: false,
    // CID of "signature" object inserted as a key of "attestation"
    timestampedValue: CID(bafyreialprnoiwl25t37feen7wbkwwr4l5bpnokjydkog3mhiuodi2av6m)
  },
  attestation: {
    // CID of asset file, same CID as in the database key
    CID: CID(bafkreif7gtpfl7dwi5nflge2rsfp6vq6q5kkwfm7uvxyyezxhsnde5ly3y),
    value: 'Web archive foo bar',
    attribute: 'description',
    encrypted: false,
    timestamp: '2023-05-29T19:03:28.601Z'
  }
}
```

The binary data of `timestamp.proof` does not have a specified size, the size mentioned above is just an example and may vary in some cases.

When `CID(...)` is shown that represents a CID stored natively, not as text. Thanks to the DAG-CBOR encoding we are able to do this. We are also able to get the CID of non-files such as particular DAG-CBOR objects. This is what allows the usage of CIDs for `signedMsg` and `timestampedValue`.

Some information already in the database key is repeated in the `attestation`, such as `CID` and `attribute`. This allows for export of the whole object for external verification and use elsewhere.

When the attestation is encrypted, the schema looks very similar to the above. The only change is `attestation.encrypted` is `true`, and `attestation.value` is always binary data. That binary data, once decrypted, is a DAG-CBOR encoding of whatever the original value was: object, binary data, string, integer, etc.

## Timestamping

Attestations are timestamped with [OpenTimestamps](https://opentimestamps.org/). This requires Internet access and takes about one second to finish. At first only the incomplete proof is stored (indicated by `timestamp.upgraded` being `false`), but the proof can be upgraded at a later date.

The timestamp serves to prove that the attestation was not made after `attestation.timestamp`, within the several hours long error bars afforded by the system. In practice, this means `attestation.timestamp` is provably accurate to about a day interval.

If you trust the signer you can ignore the proof and rely on `attestation.timestamp` alone, making it accurate to about a second.

### Timestamping methods

Modern [trusted timestamping](https://en.wikipedia.org/wiki/Trusted_timestamping) methods usually fall into two groups. Centralized timestamping requires trusting a central authority that will sign your data (or a hash) with a timestamp. Decentralized timestamping requires inserting your data (or a hash) into a timestamped widely-copied database, such as a blockchain or a printed newspaper.

This repo currently uses decentralized timestamping via [OpenTimestamps](https://opentimestamps.org/), which uses the Bitcoin blockchain and could support other blockchains in the future.

There is an existing standard for centralized timestamping, [RFC 3161](https://datatracker.ietf.org/doc/html/rfc3161), but it isn't used here due to the large proof size that would be need to be stored for each attestation. See [this issue](https://github.com/starlinglab/authenticated-attributes/issues/40) for more details.

## Verifiable Credentials

It is possible to export attestations as [Verifiable Credentials](https://en.wikipedia.org/wiki/Verifiable_credentials) as defined by the W3C. Here is an example VC generated by this software.

```jsonc
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "urn:authattr:vc-schema:1"
  ],
  // CID of "attestation" field in attestation, the part that gets signed
  // Because the credential is just a transformation of this
  "id": "urn:cid:bafyreietqpflteqz6kj7lmdqz76kzkwdo65o4bhivxrmqvha7pdgixxos4",
  "type": ["VerifiableCredential", "AuthAttrCredential"],
  "issuer": "urn:authattr:pubkey:82zNiAAng99HblAvTe2mjsC3fQ-gI416b0fNLiNmS8s=",
  // Timestamp from attestation, not timestamp of VC creation
  "issuanceDate": "2023-07-13T14:34:17Z",
  "credentialSubject": {
    // CID of the file, as that is what the claims in this credential are about
    "id": "urn:cid:bafkreif7gtpfl7dwi5nflge2rsfp6vq6q5kkwfm7uvxyyezxhsnde5ly3y",
    // Fields copied from attestation schema:
    "attribute": "description",
    "value": "Web archive foo bar",
    // Explains the how to decode what has been stored at "value"
    "encoding": "json", // "json", "base64_dag-cbor", "base64_encrypted_dag-cbor"
  },
  "proof": {
    "type": "authattr_ed25519_v1", // Something unique
    "pubKey": "<base64-encoded public key>",
    "signature": "<base64-encoded signature>"
  }
}
```

The signature of the attestation can be verified from the VC alone, by reconstructing the DAG-CBOR of the original schema `attestation` field and checking the signature from the VC `proof` section against the CID of the reconstructed `attestation` field.

### Schema Table

| Key                           | Type                                                          | Notes                                                                                                                                      |
| ----------------------------- | ------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| `@context`                    | array of URIs                                                 | First string is always `https://www.w3.org/2018/credentials/v1`, second is the auth. attr. schema with version: `urn:authattr:vc-schema:1` |
| `id`                          | URI                                                           | CID of the original attestation DAG-CBOR, using `urn:cid:`                                                                                 |
| `type`                        | array of strings                                              | Always `["VerifiableCredential","AuthAttrCredential"]`                                                                                     |
| `issuer`                      | URI                                                           | Signer public key, using our special URN `urn:authattr:pubkey:`                                                                            |
| `issuanceDate`                | timestamp                                                     | Timestamp originally stored with attestation                                                                                               |
| `credentialSubject.id`        | URI                                                           | CID of the file the attestation is about, using `urn:cid:`                                                                                 |
| `credentialSubject.attribute` | string                                                        | Attestation attribute                                                                                                                      |
| `credentialSubject.value`     | any                                                           | Attestation value, possibly encoded (see `encoding`)                                                                                       |
| `credentialSubject.encoding`  | one of `json`, `base64_dag-cbor`, `base64_encrypted_dag-cbor` | Explains how to decode `value`. `json` means it is stored natively.                                                                        |
| `proof.type`                  | string                                                        | Always `authattr_ed25519_v1`, except for version updates                                                                                   |
| `proof.pubKey`                | string                                                        | Base64-encoded ed25519 public key                                                                                                          |
| `proof.signature`             | string                                                        | Base64-encoded ed25519 signature                                                                                                           |
